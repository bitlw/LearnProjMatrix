<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
        <title>complete test</title>
        <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100% }
        </style>
    </head>
    <body>
        <script src="./js/three.min.js"></script>
        
        <script>
            // -------- 你可以修改下面的值来进行测试 --------- //
            var zPositive = true; // 设置为 true 则观察方向为 z 的正半轴，设置为 false 则观察方向为 z 的负半轴

            // 设置视口参数
            var windowWidth = 640;
            var windowHeight = 480;

            // 用来渲染图形的窗口大小，它不同于窗口大小
            var viewStartX = 40; // z_positive.html 和 z_negtive.html中的 viewStartX 和 viewStartY 都为 0
            var viewStartY = 60;
            var viewWidth = 580; //  viewStartX + viewWidth <= windowWidth; 我也不知道超过了会发生什么； viewHeight 同样
            var viewHeight = 400; // z_positive.html 和 z_negtive.html中的这两个参数都和 windowWidth 和 windowHeight 相等

            // 设置摄像机内参矩阵 K
            // zPositive = true  时 K = [[fx, 0, u0],  [0, fy, v0], [0, 0, 1]
            // zPositive = false 时 K = [[-fx, 0, u0], [0, fy, v0], [0, 0, 1]
            var fx = 565.5;
            var fy = 516.3;
            var u0 = 328.2; 
            var v0 = 238.8;
            var calibrationWidth = 640; // 摄像机在标定时候的分辨率
            var calibrationHeight = 480;

            // 设置远近裁剪面
            var near = 0.5;
            var far = 1000;
            // -------- 你可以修改上面的值来进行测试 --------- //

            // K 的参数往往需要根据渲染窗口大小进行缩放，注意这里用的是 viewWidth 而不是 windowWidth
            ratioX = viewWidth / calibrationWidth;
            ratioY = viewHeight / calibrationHeight;
            fx = fx * ratioX;
            fy = fy * ratioY;
            u0 = u0 * ratioX;
            v0 = v0 * ratioY;

            var projectionMatrix = new THREE.Matrix4();
            // 旋转和平移矩阵 [R t; 0 0 0 1]
            // 这里 R/t 的定义是摄像机坐标系到世界坐标系的变换矩阵，也就是 q = R * p + t, p 是空间中的一点在世界坐标系中的坐标，q 是该点在摄像机坐标系中的坐标
            // 这里 R/t 的定义仅仅是我习惯的定义
            var transformMatrix = new THREE.Matrix4(); 
            
            if (zPositive) { // 参考 z_positive.html 中的设置
                var l = - u0 / fx * near;
                var r = (viewWidth - u0) / fx * near;
                var t = - v0 / fy * near;
                var b = (viewHeight - v0) / fy * near;
                
                var A =  - (far + near) / (near - far);
                var B = 2 * (far * near) / (near - far);
                
                projectionMatrix.set(2*near/(r-l), 0, - (r + l) / (r - l), 0,
                                0, 2*near/(t - b), - (t + b) / (t - b), 0,
                                0, 0, A, B,
                                0, 0, 1, 0);

                // 可以修改 R/t 数据，但可能会有些困难，算错了可能会让物体不在视野范围内
                transformMatrix.set(0.4608, 0, -0.8875, 3.5841, 
                                    0.4045, -0.8901, 0.2100, 9.0800, 
                                    -0.7900, -0.4558, -0.4102, 70.0336, 
                                    0, 0, 0, 1);
            }
            else { // 参考 z_negative.html 中的设置
                var l = - u0 / fx * near;
                var r = (viewWidth - u0) / fx * near;
                var t = v0 / fy * near;
                var b = (v0 - viewHeight) / fy * near;
                
                var A =  (far + near) / (near - far);
                var B = 2 * (far * near) / (near - far);
                
                projectionMatrix.set(2*near/(r-l), 0, (r + l) / (r - l), 0,
                              0, 2*near/(t - b), (t + b) / (t - b), 0,
                              0, 0, A, B,
                              0, 0, -1, 0);

                // 可以修改 R/t 数据，但可能会有些困难，算错了可能会让物体不在视野范围内
                transformMatrix.set(-0.7071, 0.7071, 0, 0, 
                                -0.4083, -0.4083, 0.8165, 0, 
                                0.5774, 0.5774, 0.5774, -86.603, 
                                0, 0, 0, 1);
            }
            
    
            // 利用 K 来计算 PerspectiveCamera 需要的参数，相当于 OpenGL 里面使用函数 gluPerspective
            var camera = new THREE.PerspectiveCamera( 45, viewWidth / viewHeight, near, far ); // 随意设置，会被后面的替换
            camera.projectionMatrix = projectionMatrix; // 设置投影矩阵取代上面初始化时候的设置

            // 注意！ three.js 里面camera定义的矩阵是世界坐标系到相机坐标系的变换矩阵，和我常用的定义相反，因此需要求逆. 
            // 如果在OpenGL里面直接操作ModelView那个矩阵则不用求逆
            camera.applyMatrix(transformMatrix.getInverse(transformMatrix));

            // [u;v;1] = K * (R * [x; y; z] + t)) / zc
            // 注意这里使用的 R 和 t 就是transformMatrix里面的值，不用求逆
            var O = new THREE.Vector3( 0, 0, 0); // 世界坐标系原点; 请自己计算 (u, v) 坐标，类似 z_positive.html/z_negtive.html 中的例子
            var X = new THREE.Vector3( 10, 0, 0); // 世界坐标系 x 轴上的一点;
            var Y = new THREE.Vector3( 0, 10, 0); // 世界坐标系 y 轴上的一点; 
            var Z = new THREE.Vector3( 0, 0, 10); // 世界坐标系 z 轴上的一点;
            var P = new THREE.Vector3( 10, 15, 20); // 世界坐标系中的任意一点; 
            var Q = new THREE.Vector3( -10, 15, -20); // 世界坐标系中的任意一点; 

            var scene = new THREE.Scene();
            addVector(scene, O, X, 0xff0000);
            addVector(scene, O, Y, 0x00ff00);
            addVector(scene, O, Z, 0x0000ff);
            addVector(scene, O, P, 0xffffff);
            addVector(scene, O, Q, 0xff00ff);

            // 图形渲染完毕后可以将鼠标移至上面那些点的位置，查看是否与上面计算的的图像坐标(u, v)一致
            document.addEventListener("mousemove", function(event) {
                console.log("Mouse position:", event.clientX, event.clientY);
                });

            var renderer = new THREE.WebGLRenderer();
            renderer.setSize( windowWidth, windowHeight );
            renderer.setViewport(viewStartX, viewStartY, viewWidth, viewHeight); // 这里的(viewStartX, viewStartY)是左上角点，而OpenGL 中的 glViewport 是左下角点

            document.body.appendChild( renderer.domElement );
            renderer.render(scene, camera);

            function addVector(scene, startPoint, endPoint, color) {
                var geometry = new THREE.Geometry();
                geometry.vertices.push(startPoint);
                geometry.vertices.push(endPoint);            
                var material = new THREE.LineBasicMaterial( { color: color });
                var line = new THREE.Line( geometry, material );
                
                scene.add( line );
            }

        </script>
    </body>
</html>